/* Generated by Together */

#include "stdafx.h"
#include "EPropWnd.h"
#include "IPropertyHost.h"
#include "EProperty.h"

EProperty::EProperty( IPropertyHost* pHost , const CString& sName , void* pProperty , bool bEnabled )
{
	m_pProperty   = pProperty;
	m_pHost       = pHost;
	m_sName       = sName;
	m_bSelected   = false;
	m_bEnabled    = bEnabled;
	m_nIndent     = 0;

	m_bNodeOpen    = false;
	m_bHasChildren = false;

	m_pParentHost  = NULL;
}
EProperty::~EProperty()
{
//	TRACE("Destroying EProperty!\n");
}

bool EProperty::OnCommand( EPropWnd* pParent , WPARAM wParam , LPARAM lParam )
{
	return false;
}

bool EProperty::IsSelected()
{
	return m_bSelected;
}

int EProperty::GetPreferedWidth( CDC* pDC )
{
	return 50;
}

int EProperty::GetHeight()
{
	return 100;
}

int EProperty::GetHeight( CDC* pDC )
{
	return GetHeight();
}

bool EProperty::IsEnabled()
{
//---------------------------------------------------------------------
// parsing null as the property shouldn't result in read only, read only should be set specific in m_bEnabled
// this greatly simplifies thing as to when a property is readonly (it's either set readonly, or host wants it)
//---------------------------------------------------------------------
//	bool bEnabled = m_pProperty!=NULL;
//
//	if( bEnabled )
//	{
//		bEnabled = m_bEnabled;
//
//		if( m_bEnabled )		//if set to false, don't even ask host..
//		{
//			bEnabled = m_pHost->IsPropertyEnabled( m_pProperty );
//		}
//	}
//---------------------------------------------------------------------

	bool bEnabled = m_bEnabled;

	if( m_bEnabled )		//if set to false, don't even ask host..
	{
		bEnabled = m_pHost->IsPropertyEnabled( m_pProperty );
	}

	return bEnabled;
}

void EProperty::DrawHover( CDC* pDC ,  EPropWnd* pView )
{
	Draw( pDC , pView );

	CPen pen;
	pen.CreatePen( PS_SOLID , 0 , RGB(255,0,0) );
	pDC->SelectObject(&pen);

	pDC->SelectStockObject(NULL_BRUSH);
	pDC->Rectangle(m_Rect);
}

void EProperty::Draw( CDC* pDC ,  EPropWnd* pCtrl )
{
	if( m_bSelected )
	{
		pDC->FillSolidRect( &m_Rect , pCtrl->GetColorPaneValActive() );
	}
	else
	{
		pDC->FillSolidRect( &m_Rect , pCtrl->GetColorPaneVal() );
	}
}

void EProperty::OnPropActivate( EPropWnd* pParent )
{
}

bool EProperty::OnPropApply()
{
	return false;
}

void EProperty::OnPropClose()
{
}

bool EProperty::OnLButtonDown( EPropWnd* pParent , CPoint p )
{
	return false;
}

bool EProperty::OnSpaceKey()
{
	return false;
}


CString EProperty::GetName()
{
	return m_sName;
}

COLORREF EProperty::GetColorKey( EPropWnd* pCtrl )
{
	COLORREF nColor = pCtrl->GetColorPaneKey();

	if( IsSelected() )
	{
		nColor = pCtrl->GetColorPaneKeyActive();
	}

	return nColor;
}

bool EProperty::IsSelectable()
{
	return true;	//IsEnabled();
}

CString EProperty::GetSortValueString()
{
	return "";
}

bool EProperty::GetSortValueDouble( double& dValue )
{
	return false;
}

int EProperty::CompareValues( EProperty* pProperty )
{
	int nResult = 0;

	if( pProperty == NULL )
	{
		return true;
	}

	bool bGreater = false;

	double d1;
	double d2;

	bool b1 = GetSortValueDouble(d1);
	bool b2 = pProperty->GetSortValueDouble(d2);

	if( b1 && b2 )
	{
		if( d1 < d2 )
		{
			nResult = -1;
		}
		else if( d1 > d2 )
		{
			nResult = 1;
		}
		else
		{
			//they are the same, leave a zero at nresult
		}
	}
	else
	{
		CString s1 = GetSortValueString();
		CString s2 = pProperty->GetSortValueString();
		nResult = s1.Compare(s2);
	}

	return nResult;
}

EProperty* EProperty::SetComment( const CString& sComment )
{
	m_sComment = sComment;
	return this;
}

CString EProperty::GetComment()
{
	return m_sComment;
}

bool EProperty::CanApply()
{
	return true;
}
